\section{Stand der Technik}
Um die Implementierung der Arbeit vollständig nachvollziehen zu können, ist es wichtig, einige Konzepte verstanden zu haben und zu wissen, worauf die Entwicklung aufbauen wird. Diese Grundlagen werden im Folgenden eingeführt und erläutert.

\subsection{Einführung in Frontend-Frameworks für Webapplikationen}
Die Entwicklung interaktiver Webapplikationen erfolgt mittels HTML, CSS und JavaScript. Browser stellen den mit HTML definierten Inhalt dar, manipulieren das Aussehen der Seite anhand der durch CSS definierten Regeln und verfügen zudem über einen JavaScript Interpreter, der den übermittelten JavaScript Code ausführen kann und darüber eine Manipulation der Seiteninhalte erlaubt.

Durch diese Möglichkeit ergibt sich das Problem, dass die Daten, die das Programm berechnet (oder auf andere Weise erlangt) Nutzenden korrekt dargestellt werden und umgekehrt Eingaben von Nutzenden in den Daten widergespiegelt werden sollen.

Beim Entwickeln solcher Funktionalität wiederholen sich häufig bestimmte Probleme wie die Synchronisierung von Daten mit der Anzeige oder die Wiederverwendung von Teilen der Nutzeroberfläche. Diese Probleme können mit Hilfe von Frontend-Frameworks gelöst werden.

Zur Zeit gibt es vor allem drei Frameworks, die häufig verwendet werden: React, Angular und Vue \cite{stateofjs}. Angular und Vue bauen dabei auf dem \gls{MVVM}-Pattern auf \cite{angular_mvvm}. Dort kann jeweils in einer Variation von HTML, in der bestimmte JavaScript- bzw. TypeScript-Ausdrücke interpretiert werden können, die View aufgebaut werden. Die Funktionalität des ViewModels wird in einem zur View gehörenden JavaScript- bzw. TypeScript-Block implementiert und das Model kann über weitere Klassen dargestellt werden. Während in Angular View, ViewModel und Model in verschiedene Dateien aufgeteilt werden, sind in Vue die View und das ViewModel in derselben Datei zu vereinen.

React hingegen verfolgt nicht so strikt das \gls{MVVM}-Pattern. Hier wird durch die freiwillige, aber empfohlene Verwendung zusätzlicher Syntax ermöglicht, eine Variante von HTML-Ausdrücken in JavaScript bzw. TypeScript einzufügen, die dann wie andere Werte auch in Variablen gespeichert werden können \cite{react_jsx}. Auf diesem Weg wird parallel zum eigentlichen \gls{DOM} ein sogenanntes Virtual DOM generiert, das dann in das eigentliche \gls{DOM} überführt wird. Somit ist es in React möglich, View und Controller komplett miteinander zu vereinen.

Alle drei dieser Frameworks ermöglichen eine komponentenbasierte Entwicklung. Das bedeutet, dass mit sehr geringem Aufwand die View in Komponenten unterteilt werden kann, die dann wiederverwendet werden können.

Aus diesen und weiteren Gründen verwenden die meisten Webentwickelnden Frontend-Frameworks um darauf ihre Projekte aufzubauen \cite{stateofjs}. Da jedes Frontend aber mehr oder weniger klare Strukturen, Datenflüsse, Syntaxen und vieles mehr vorgibt, ist die Entscheidung eines Frameworks in Bezug auf die Suche weiterer Abhängigkeiten eine sehr folgenschwere Entscheidung.

Beispielsweise ist es im Rahmen der empfohlenen Installationsprozesse nicht möglich, Angular ohne TypeScript oder React ohne ESLint zu verwenden \cite{angular_only_with_typescript} \cite{react_eslint}. Für alle drei der genannten Frameworks gibt es Komponentenbibliotheken\footnote{Material-UI für React: \url{https://material-ui.com/}; Angular Material: \url{https://material.angular.io/}; Vuetify für Vue: \url{https://vuetifyjs.com/en/}}, die Google's Material Design System folgen; allerdings sind diese Bibliotheken sehr verschieden, haben unterschiedliche Features und gehen nicht aus demselben Code hervor.

Die Entscheidung eines Frameworks ist daher eine der ersten Entscheidungen, die Entwickelnde beim Einrichten ihrer Projekte treffen müssen. Sie schränkt die weitere Auswahl an Werkzeugen und Bibliotheken ein. Außerdem können, bis auf in besonderen Kontexten wie Micro-Frontends oder WebComponents, nur mit hohem Aufwand oder gar nicht zwei Frameworks zusammen verwendet werden.

\subsection{Kommandozeileninterfaces}
Die erste Art von Programmen, die auf Computern ausgeführt werden konnten, waren sogenannte Kommandozeileninterfaces (\gls{CLI}s). Über die Kommandozeile konnten diese Programme über ihren Namen bzw. ihren Speicherort aufgerufen werden, wobei zusätzliche Argumente übergeben werden konnten, um den Ablauf des Programms zu beeinflussen\cite{verma2013gracoli}.

Diese Benutzweise birgt verschiedene Vor- und Nachteile. A priori bietet sie keine Entdeckbarkeit der Funktionalität. Erst durch die Einrichtung eines weiteren Befehls bzw. einer Konfigurationsoptionen kann Nutzenden eine Liste aller Nutzungsmöglichkeiten des Programms angezeigt werden. Nutzende müssen aber auch diesen Befehl kennen, um ihn ausführen zu können. Dafür lassen sich derartige Befehle sehr leicht automatisiert ausführen, da sie ohne weiteres in Skripte eingebunden werden können. Um eine automatische Ausführung grafischer Benutzungsoberflächen zu ermöglichen, müsste dahingegen die Benutzung einer Computermaus simuliert werden \cite{fellmann2007command}.

Seit diesen Anfängen von \gls{CLI}s ist es jedoch möglich geworden, im Rahmen eines \gls{CLI}s weitere Nutzereingaben wie die Verwendung von Tastatur und Maus zu verarbeiten. So können Nutzerinteraktionen ermöglicht werden, die einer grafischen Benutzeroberfläche gleich kommen. Beispielsweise ist es möglich, in der Kommandozeile sich eine Weltkarte anzuzeigen, die mit Maus und Tastatur bedienbar ist \cite{mapscii}.

Heutzutage bieten \gls{CLI}s daher den Vorteil, dass sie weiterhin leicht automatisierbar sind und dennoch Interaktivität und damit Entdeckbarkeit der Funktionen ermöglichen. Um derartige Interaktivität leichter umzusetzen, gibt es zahlreiche Bibliotheken.

\subsection{Ähnliche Projektgeneratoren}
Um das Problem der initialen Projektkonfiguration zu automatisieren oder zumindest zu erleichtern, bieten die drei oben erwähnten Frameworks jeweils ein Programm an, was zur initialen Erstellung von Projekten mit dem jeweiligen Framework empfohlen wird. Einige dieser Programme sind darüber hinaus in der Lage, auch nach der initialen Erstellung Änderungen am Code vorzunehmen. Diese Features sind jedoch für \gls{GWA} nicht geplant und werden daher nicht näher betrachtet.

\subsubsection{React}
In der Dokumentation für React wird empfohlen, neue Projekte über das \gls{CLI} \gls{CRA} zu erstellen. Dieses kann per \gls{npm} installiert werden und ist dann in der Lage, den Inhalt eines angegebenen Templates (oder des Standardtemplates) in ein spezifiziertes Verzeichnis zu kopieren. Daraufhin werden die benötigten Abhängigkeiten per \gls{npm} oder mittels eines anderen installierten Paketmanagers (wie z.B. Yarn) installiert.

Dritten ist es möglich, eigene Templates für \gls{CRA} zu erzeugen, die dann wie Erstanbietertemplates zur Erzeugung des neuen Projekts genutzt werden können. Wenn also mittels \gls{CRA} ein Projekt erzeugt werden soll, das bereits mit gewissen Bibliotheken oder Werkzeugen ausgestattet ist, muss dafür dafür zuvor ein entsprechendes Template erstellt worden sein. Die Wahrscheinlichkeit, dass das jedoch passiert ist, sinkt mit der Spezifität der Wünsche.

Die Erstanbietertemplates geben bereits die empfohlene Ordner- und Dateistruktur für React-Projekte vor; durch Drittanbietertemplates kann hiervon aber abgewichen werden. Außerdem installieren die Erstanbietertemplates bereits einige weitere Werkzeuge wie ESLint, Jest (ein Werkzeug zum Schreiben und Ausführen von automatisierten Tests, in der Regel Unit Tests) und die sogenannten react-scripts. Diese sind eine Sammlung von kleinen Skripten und Abhängigkeiten, die Prozesse automatisieren, die für die Entwicklung notwendig sind. Beispielsweise wird so ein Skript zur Verfügung gestellt, welcher einen lokalen Server startet, der den aktuellen Stand der Webapplikation hostet und bei jeder Codeänderung automatisch aktualisiert. Dieser Server gibt zudem auch die Warnungen aus, die ESLint erzeugt.

Außerdem ist es bei der Verwendung dieser Templates mit geringem Aufwand möglich, bestimmte empfohlene Bibliotheken und Werkzeuge nachzurüsten. So gibt es zum Beispiel Anleitungen für die Installation von Prettier oder von CSS Präprozessoren, die aus jeweils einem in der Kommandozeile auszuführenden Befehl bestehen. Für Prettier muss zudem noch eine bestimmte, bereits existierende Datei um einige Zeilen ergänzt werden.

\subsubsection{Angular}
Das Angular-Team stellt das sog. Angular-CLI zur Verfügung, das Entwickelnden beim Programmieren verschiedene wiederkehrende und repetitive Aufgaben abnehmen soll (wie z.B. die Erstellung und Einbindung neuer Komponenten). Neben diesen Aufgaben wird das Tool auch zur Erstellung neuer Angular-Projekte genutzt.

Der Befehl ng new <project-name> führt Nutzende in einen Dialog, bei dem zwei Fragen zur gewünschten Konfiguration des Projektes gestellt werden. Über explizit gesetzte Kommandozeilenoptionen können dann insgesamt Features konfiguriert werden, mit denen das Projekt eingerichtet wird. Diese Features sind jedoch allesamt Angular-intern, d.h. es gibt keine Möglichkeit weitere Libraries oder ähnliches installieren zu lassen, die nicht direkt vom Angular Team kommen. Selbst einige Libraries (z.B. Angular Material), die vom Angular-Team direkt entwickelt werden, sind nicht in diese initiale Projektgenerierung eingebunden. Eine Ausnahme hiervon bildet die Auswählbarkeit der CSS-Präprozessoren SCSS, Sass und Less.

Im Gegensatz zu CRA sind hier die Möglichkeiten, die Nutzenden bei der initialen Projekterstellung geboten werden, sehr eingeschränkt. Es gibt die Möglichkeit, bei der Einrichtung eine sogenannte \glqq Collection\grqq\ anzugeben, die dann die Erstellung des eigentlichen Projektes übernimmt. Es könnte also eine Collection entwickelt werden, die weitere Libraries je nach Eingabe einbindet. Jedoch scheint die Umsetzung dieses Features abzunehmen: von den überprüften Collections für ESLint, Prettier und Apollo-Angular hat nur eine dieses Feature (also die Installation bei der Initialisierung statt hinterher) jemals unterstützt, hat es aber mittlerweile wieder eingestellt \cite{angular_eslint_collection_issue} \cite{prettier_angular_collection_file} \cite{apollo_angular_collection_file}.

Im Gegensatz zu der React-Lösung können sich Nutzende hier (im Rahmen der beschränkten angebotenen Optionen) eine beliebige Konfiguration aussuchen und sind nicht darauf angewiesen, dass jemand vor ihnen schon denselben Wunsch hatte. Außerdem wird durch die gestellten auch Anfänger:innen die Entdeckung und der Einstieg in Angular erleichtert, da gewisse Features automatisch an sie herangetragen werden.


\subsubsection{Vue}
Von den drei Frameworks bietet Vue in Bezug auf die Projekterstellung das umfangreichste CLI. Zu aller erst besteht die Möglichkeit, ein Preset auszuwählen. Dies kann eines von zwei Standardpresets sein oder eines, was zuvor auf dem lokalen Computer erstellt und gespeichert wurde. Es ist auch möglich, ein bereits existierendes Preset oder ein komplett neues Preset als Kommandozeilenparameter anzugeben.

Falls kein Preset ausgewählt wird, ist zunächst im Rahmen einer Multiple-Choice-Frage eine Vorauswahl von zehn Features zu treffen, die installiert werden sollen bzw. nicht installiert werden sollen. Daraufhin werden zu den ausgewählten Features detailliertere Fragen gestellt. Insgesamt stehen durch dieses Tool über 20 verschiedene Bibliotheken bzw. Libraries ohne weiteren Konfigurationsaufwand zur Verfügung. Die soeben erstellte Konfiguration kann anschließend als neues Preset gespeichert werden.

Wie im Angular-\gls{CLI} können auch hier CSS-Präprozessoren und ein Framework-spezifischer Router in das Projekt eingebunden werden. Darüber hinaus besteht jedoch eine Auswahl aus verschiedenen Werkzeugen zur statischen Codeanalyse, verschiedenen Bibliotheken und Werkzeugen sowohl für Unit- als auch für Ende-zu-Ende-Tests und weiteren vereinzelten Bibliotheken und Features.

%\subsubsection{Vergleich der Möglichkeiten zwischen Frameworks}
%Alle drei Tools bieten Entwickelnden die Möglichkeit, eigene Erweiterungen zu erarbeiten und zu veröffentlichen. Im Falle von React muss dies in Form eines Templates geschehen. Da nur ein Template zur Erstellung eines Projektes genutzt werden kann, sind derartige Erweiterungen hier also exklusiv.

%Bei Angular und React ist es jedoch möglich, auch Erweiterungen zu entwickeln, die zusätzlich zu anderen Optionen und Erweiterungen nutzbar sind. Für das Angular \gls{CLI} kann man sogenannte Schematics entwickeln, die das Hinzufügen und Einbinden einer Bibliothek vollautomatisch übernehmen. Diese Schematics müssen aber leider nach der Installation ausgeführt werden und müssen insbesondere von Nutzenden entdeckt werden. Hierfür gibt es keine eigene Plattform o.ä. und die Auswahl der Schematics, die schon bei der Projekterstellung auswählbar sind, beschränkt sich auf Angular-interne Features (z.B. die Einfügung eines Routers). Selbst Libraries, die auch vom Angular-Team betreut werden (z.B. Angular Material) müssen später per Schematic nachgerüstet werden.

%Im Rahmen des Vue \gls{CLI}'s ist es immerhin möglich, auch Libraries von Dritten direkt bei der Projekterstellung einzubinden. Allerdings ist auch hier die anfängliche Auswahl nicht erweiterbar. Dafür können, wie auch schon bei Angular, anschließend automatisch über Drittanbieterplugins neue Libraries heruntergeladen, importiert und demonstriert werden.

%Tabelle 

%  \begin{table}
%	  \centering
%	  \caption{Automatische und initiale Installierbarkeit verschiedener Features in Angular und Vue Projekten}
%	  \begin{tabular}{|l|l|l|l|l|}
%    \hline
%         & \multicolumn{2}{c|}{Angular} & \multicolumn{2}{c|}{Vue}  \\ \hline
%        Feature & Automatisch & Ititial & Automatisch & Initial \\
%        & installierbar & auswählbar & installierbar & auswählbar \\ \hline
%        TypeScript & \multicolumn{2}{c|}{wird erzwungen} & \checkmark & \checkmark \\ \hline
%        Router & \checkmark & \checkmark & \checkmark & \checkmark \\ \hline
%        PWA-Support & \checkmark & \texttimes & \checkmark & \checkmark \\ \hline
%        Linter & \checkmark & \texttimes & \checkmark & \checkmark \\ \hline
%        Formatierer & \checkmark & \texttimes & \checkmark & \checkmark \\ \hline
%        CSS Reset & \texttimes & \texttimes & \texttimes & \texttimes \\ \hline
%        CSS Präprozessor & \checkmark & \checkmark & \checkmark & \checkmark \\ \hline
%        Design Framework & \checkmark & \texttimes & \checkmark & \texttimes \\ \hline
%        State Management & \multicolumn{2}{c|}{wird erzwungen} & \checkmark & \checkmark %\\ \hline
%        Unit Testing Framework & \checkmark & \texttimes & \checkmark & \checkmark \\ \hline
%        E2E Testing Framework & \checkmark & \texttimes & \checkmark & \checkmark \\ \hline
%    \end{tabular}
%	  \label{tab:automatically_installable_libs_per_framework}
%  \end{table}

%Außerdem bieten alle drei der genannten Tools keine Unterstützung für andere Frameworks. Daher ist beispielsweise der große Umfang der Features des Vue CLI‘s leider nicht in einem Angular-Projekt nutzbar.

\subsection{Funktionale Programmierung}
Die Funktionale Programmierung ist ein Programmierparadigma, das ursprünglich der Mathematik entstammt. Wie der Name vermuten lässt, basiert in der funktionalen Programmierung alles auf Funktionen. Diese unterschieden sich jedoch von dem Begriff einer Funktion, der sonst in der Informatik geläufig ist.

Die Funktionale Programmierung versteht Funktionen in einem eher mathematischen Sinne. Eine Funktion bestimmt also basierend auf bestimmten Eingaben bestimmte Ausgaben. Wichtig ist hierbei, dass bei gleicher Eingabe die Ausgabe auch stets gleich ist. Außerdem darf die Funktion keine Seiteneffekte haben \cite{hinsen2009functional_programming}.

Eine solche Funktion dürfte also beispielsweise keine Ausgabe an Nutzende ausführen, da dies ein Seiteneffekt wäre. Eine Funktion, die die aktuelle Uhrzeit zurückgibt, wäre ebenfalls keine Funktion in diesem Sinne, da sie bei gleichbleibenden Eingaben verschiedene Ausgaben erzeugen würde.

An diesen Stellen unterscheidet sich die Funktionale Programmierung grundlegend von der Objektorientierten Programmierung. Ihr zugrunde liegen Klassen, die über Attribute und Methoden, also eine Art von Funktionen im klassischen, informatischen Sinne, verfügen. Eine Methode verändert in der Regel Attribute oder liest sie aus. Diese Methoden haben im allgemeinen nicht das Ziel, keine Seiteneffekte zu verursachen oder bei gleicher Eingabe immer die gleiche Ausgabe zu erzeugen.

In der Funktionalen Programmierung wird auch auf weitere Konzepte, die aus der Objektorientierten Programmierung bekannt sind, verzichtet. So gibt es hier keine Variablen, die modifiziert werden können, sondern Funktionen können nur unveränderliche Parameter entgegennehmen und einen neuen Wert zurückgeben. Zudem wird auf Schleifen verzichtet; äquivalente Funktionalität kann jedoch durch Rekursion implementiert werden \cite{hinsen2009functional_programming}.

Die Einschränkungen der Funktionalen Programmierung bieten einige Vorteile. Während in der Objektorientierten Programmierung oft nicht ersichtlich ist, warum eine Variable zu einem gewissen Zeitpunkt einen gewissen Wert hat, lässt sich in der Funktionalen Programmierung durch eine einfache Rückverfolgung der Funktionsaufrufe ermitteln, wo jeder Wert bestimmt worden ist.

Darüber hinaus sind Funktionen der funktionalen Programmierung oft besser zu testen \cite{hinsen2009functional_programming} \cite{benton2016js_functional}. Dies liegt unter anderem daran, dass nur die Eingabewerte übergeben und die Ausgabe überprüft werden muss. Bei Objektorientierter Programmierung müssen vor der Ausführung von Tests eventuelle Seiteneffekte verhindert werden und weitere Initialisierungen, beispielsweise von Attributen der Klasse, getroffen werden.

Die Entscheidung über die Verwendung Funktionaler Programmierung muss jedoch nicht binär sein. Viele Programmiersprachen, darunter auch JavaScript und folglich TypeScript, ermöglichen das Schreiben von funktionalem Code und verfügen gleichzeitig über Syntax für Objektorientierte Programmierung \citep{benton2016js_functional}.

Daher ist es möglich, ausgewählte Teile von Programmen nach Funktionaler Programmierung zu entwickeln und an anderen Stellen bewusst auf einzelne oder gar sämtliche Aspekte des Paradigmas zu verzichten. So können an diesen Stellen dennoch die erwähnten Vorteile genossen werden.

\subsection{Testgetriebene Entwicklung}
\label{state_of_the_art:tdd}
Der Begriff der Testgetriebenen Entwicklung, im Englischen auch \gls{TDD} genannt, bezeichnet ein bestimmtes Vorgehen beim Programmieren, das zu zuverlässigerem Code führen soll und das dazu beitragen soll, dass weniger ungebrauchter Code geschrieben wird \cite{tdd_beck}.

Während der Entwicklung werden wiederholt drei Phasen durchlaufen. Zunächst wird ein automatisierter Test geschrieben, der eine noch nicht implementierte Funktionalität testet. Diese erste Phase wird erst beendet, wenn der Test fehlschlägt. So wird garantiert, dass der Test nicht versehentlich immer funktioniert (z.B. weil er versehentlich eine andere, bereits implementierte Funktionalität testet).

In der zweiten Phase wird dann die gewünschte Funktionalität implementiert. Hierbei wird jedoch darauf geachtet, dass nur so viel Code geschrieben wird, wie notwendig ist, um den zuvor geschriebenen Test bestehen zu lassen. Hierbei wird jeder Anspruch auf Codequalität außer Acht gelassen, sodass der Fokus darauf liegt, mit minimalem Aufwand den Test zu beheben.

Im Anschluss an die zweite Phase hat man eine Lösung, von der man weiß, dass sie Funktioniert (da sie den zuvor geschriebenen Test und alle präexistenten Tests besteht). Diese Lösung muss zunächst gesichert werden, bevor in der dritten Phase der Code aufgeräumt werden kann. In diesem Schritt können Verbesserungen der Codequalität, der Laufzeit oder sonstiger Kriterien vorgenommen werden. Es ist jedoch bei allen Änderungen stets darauf zu achten, dass weiterhin kein Test fehlschlägt. Sollte dies dennoch geschehen, so kann jederzeit der Code auf den Stand von Phase 2 zurückgesetzt und erneut mit Phase 3 begonnen werden.

Nach der dritten Phase ist somit Code entstanden, der sämtlichen Qualitätsansprüchen genügt. Er ist außerdem durch automatische Tests abgedeckt, von denen bekannt ist, dass sie bei Entfernung des Features fehlschlagen würden. Dieser Stand ist nun zu Sichern und die Entwicklung des nächsten Features beginnt erneut mit der ersten Phase.
