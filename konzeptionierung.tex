\section{Konzeptionierung}
\label{komzeptionierung}
Angesichts dessen, dass das geplante \gls{CLI} verschiedenste Bilbiotheken und Werkzeuge unterstützen können soll und dabei auch zukunftssicher bleiben soll, ist es unabdingbar, die Entwicklung im Vorhinein zu planen. Hierfür muss zunächst untersucht werden, welche Gemeinsamkeiten und welche Unterschiede bei verschiedenen Installationsprozessen vorliegen. Daraufhin kann dann ein System erarbeitet werden, was die Gemeinsamkeiten fördert und gleichzeitig Raum für die bekannten, aber auch möglichst für erwartbare unbekannte Unterschiede lässt.

\subsection{Auswahl der zu vergleichenden Installationsprozesse}
Um zu bestimmen, welche Schritte bei der Einrichtung von neuen Projekten durchführbar sein müssen, wurden zunächst verschiedenste Projekte erstellt, zu denen dann möglichst verschiedene Abhängigkeiten und Werkzeuge hinzugefügt wurden.

Aufgrund der bereits erläuterten Beliebtheit von Frontend-Frameworks wurde für jedes der drei bekanntesten Framework ein Projekt erstellt, in dem dann die entsprechenden Installationen durchgeführt wurden. Für diese initiale Erstellung wurde jeweils das bereits vorgestellte \gls{CLI} verwendet.

Bei der Auswahl dessen, was zu diesen Projekten hinzugefügt wurde, lag der Fokus zum einen auf Bekanntheit und Verbreitung und zum anderen auf Vielseitigkeit. Da sich ähnliche Werkzeuge oft auch in ihrem Installationsprozess ähneln (beispielsweise waren die Schritte zur Installation von ESLint fast identisch zu den Schritten zur Installation von TSLint\footnote{\url{https://palantir.github.io/tslint/}}), ist es für diese Vorbereitung also nicht nötig, eine Abhängigkeit hinzuzufügen, wenn bereits eine andere ausprobiert wurde, die einen ähnlichen Funktionsumfang hat.

\subsubsection{Untersuchte Werkzeuge}
Aus diesen Gründen wurden sechs verschiedene Werkzeuge installiert. Das erste dieser Werkzeuge ist ESLint, ein Werkzeug zur statischen Codeanalyse für JavaScript. Es gibt Warnungen aus, wenn bestimmte Ausdrücke verwendet wurden, die häufig zu Bugs führen (z.B. die Verwendung von einem doppelten Gleichheitszeichen anstelle eines dreifachen Gleichheitszeichens, d.h. die typunsichere Gleichheitsüberprüfung anstelle Gleichheitsprüfung mit Prüfung auf Typgleichheit).

ESLint verfügt auch über die Möglichkeit, Formatierungspräferenzen anzugeben. Diese werden in die Analyse mit einbezogen und darüber können beispielsweise Warnungen ausgegeben werden, wenn Zeilen falsch eingerückt sind. Einige Warnungen, darunter die meisten Warnungen zur Formatierung, können von ESLint auf Wunsch automatisch behoben werden. Standardmäßig ist ESLint jedoch nur passiv, also idempotent.

ESLint wird stellvertretend für alle Werkzeuge zur statischen Codeanalyse überprüft. Insbesondere entfällt deshalb die Überprüfung von TSLint; zumal das Projekt veraltet ist und die Entwicklung zugunsten von ESLint aufgegeben wurde \cite{tslint_deprecation} \cite{tslint_repo}. Da es aber noch automatisch mit Angular zusammen installiert wird, hätte man seine Überprüfung dennoch in Betracht ziehen können.

Des weiteren wurde Prettier untersucht. Dies ist ein Codeformatierer, der unter freiwilliger Angabe von Konfigurationseigenschaften Code einheitlich formatiert (d.h. Einrückungen werden korrigiert, Leerzeichen vor oder hinter Klammern eingefügt oder entfernt etc.). Gegenüber ESLint hat Prettier den Vorteil, nicht nur JavaScript-basierte Dateien formatieren zu können, sondern es kann auch mit anderen Dateiformaten wie Markdown oder CSS umgehen.

Darüber hinaus kann Prettier auch ohne Konfiguration (d.h. ohne Festlegung von Präferenzen) aufgerufen werden um Code zu formatieren. ESLint hingegen muss ausgiebig konfiguriert werden, damit der Code formatiert wird. Zudem hat Prettier in Bezug auf Formatierung mehr Einstellmöglichkeiten als ESLint. Gleichzeitig gibt es gewisse Aspekte der Formatierung, die von Prettier vorgegeben werden und nicht einstellbar sind.

Als drittes wurden SCSS / Sass\footnote{\url{https://sass-lang.com/}} betrachtet. Dies sind zwei Dialekte eines CSS-Präprozessors. Dieser Präprozessor erweitert die CSS-Syntax um eine weitere Art von Variablen, Verschachtelung, sogenannten \glqq Mixins\grqq\ und weitere Features. Zur Kompilierzeit wird daraus normales CSS erzeugt. Dank der zusätzlichen Funktionen kann kompakteres, wiederholungsfreieres und oft auch leserlicheres CSS geschrieben werden.

Zugunsten von SCSS / Sass wurde auf die weitere Überprüfung anderer Präprozessoren wie Less\footnote{\url{https://lesscss.org/}} verzichtet.

Mit Jest wurde außerdem eine Bibliothek zum Schreiben und Ausführen automatisierter Tests untersucht. Diese werden in Node.js ausgeführt und verfügen daher a priori nicht über Browserspezifische APIs (wie z.B. Zugriff auf Canvas-Elemente). Viele dieser Funktionalitäten sind aber ggf. über weitere Bibliotheken Nachrüstbar. In der Regel wird Jest für Unittests verwendet.

Im Vergleich zu anderen Werkzeugen vereint Jest mehrere Funktionalitäten, die sonst über mehrere Abhängigkeiten aufgeteilt sind. Wo sonst der Ausführer der Tests von der Bibliothek zur Aufstellung und Überprüfung von Annahmen (Engl.: \glqq Assertion Library\grqq) und der Mockingbibliothek getrennt ist und zur Erzeugung eines Berichtes über die Testabdeckung eine weitere Bibliothek notwendig ist, bietet Jest alle diese Features gleichzeitig an.

Seit 2019 ist Jest das meist verbreitetste Werkzeug zum Schreiben von JavaScript-Tests \cite{stateofjs} und unterstützt dabei alle drei Frameworks. Außerdem ist seine Installation vergleichsweise sehr simpel, da hier nicht mehrere Werkzeuge zusammen installiert und miteinander eingerichtet werden müssen. Da diese höhere Komplexität also vermeidbar ist, werden andere Bibliothekskombinationen für Unittests nicht näher betrachtet.

Cypress, das vierte Werkzeug, dessen Installation betrachtet wurde, ist ein weiteres Werkzeug zum Schreiben automatisierter Tests, allerdings mit dem wichtigen Unterschied zu Jest, dass die Tests im Browser ausgeführt werden. Daher eignet sich Cypress vor allem zum Schreiben von Ende-zu-Ende-Tests, da hier die Applikation vollständig ausgeführt werden kann und lediglich die Nutzerinteraktion simuliert werden muss.

Aktuell ist Cypress in der Lage, Chromium-basierte Browser und Firefox zu kontrollieren, um das Laden und die Interaktion mit einer Seite nicht nur per Node.js zu simulieren, sondern entsprechende Ereignisse in einem Browser so auszulösen, dass sie nicht (in relevantem Ausmaß) von tatsächlichen Userinteraktionen unterschieden werden können. Außerdem stehen in diesen Tests die Browser-APIs in vollem Umfang zur Verfügung.

Seit 2020 wird Cypress öfter als vergleichbare Projekte wie Puppeteer, WebdriverIO, Selenium oder Playwright verwendet \cite{stateofjs}, weshalb diese zugunsten von Cypress nicht weiter berücksichtigt werden.

Zum Schluss wirden Husky und lint-staged untersucht. Diese stellen eine Kombination von Werkzeugen dar, die die Ausführung anderer Werkzeuge als Reaktion auf bestimmte Ereignisse ermöglichen.

Einige der zuvor aufgeführten Werkzeuge bieten Leistungen an, die dabei helfen können, sicherzustellen, dass in ein \gls{VCS} eingepflegter Code immer gewissen Standards entspricht. Die automatischen Tests können beispielsweise garantieren, dass kein zuvor existierendes (und von Tests abgedecktes) Feature kaputt gemacht worden ist, und Prettier und ESLint könne garantieren, dass der Code einem gewissen Stil entspricht. Andere Werkzeuge wie CSS-Präprozessoren hingegen bieten in dieser Hinsicht keine weiteren Vorteile.

Um die Qualität des Codes auf einem möglichst hohen Niveau zu halten, kann es also sinnvoll sein, diese entsprechenden Werkzeuge automatisch vor der Einpflegung des Codes in ein \gls{VCS} ausführen zu lassen. Genau diese Möglichkeit bietet Husky, sofern das \gls{VCS} Git verwendet wird. Diese Annahme lässt sich durchaus treffen, da Git mit einer Nutzungsquote von 94,41\% unter professionellen Entwickelnden das am weitesten verbreitete \gls{VCS} ist \cite{git_usage}.

Mithilfe von Husky lassen sich mit wenig Konfigurationsaufwand Skripte festlegen, die vor dem Speichern von Code in Git ausgeführt werden sollen. Scheitert eines dieser Skripte, so wird der Speichervorgang abgebrochen. Lint-staged erleichtert hierbei das Überprüfen der geänderten Dateien, sodass nicht bei jeder Änderung der gesamte Code geprüft werden muss. Dennoch kann die Ausführung dieser Prozesse den Speichervorgang verzögern, was bei großen Projekten unerwünscht sein kann.

Aufgrund dessen, dass diese beiden Werkzeuge empfohlen werden, um Prettier automatisch vor entsprechenden Vorgängen laufen zu lassen, und da ihre Verwendung sich leicht auf zusätzliche Werkzeuge erweitern lässt, werden Husky und lint-staged vergleichbaren Alternativen vorgezogen.

\subsubsection{Untersuchte Bibliotheken}
Neben den Werkzeugen wurden von insgesamt vier Bibliotheken bzw. Bibliotheksarten die Installationsprozesse betrachtet.

Die erste solche Bibliotheksart sind Router. Jedes der drei Frameworks verfügt über eine Unterbibliothek um verschiedene Routen einzurichten. Durch sie kann ohne ein Neuladen der Seite die URL gewechselt werden, diese Änderung auch im Browserverlauf widergespiegelt werden und auch schon beim Aufruf einer Unter-URL direkt die entsprechende Komponente angezeigt werden. Schon die Tatsache, dass die Installation eines Routers in Angular- und Vueprojekten schon bei der initialen Einrichtung ausgelöst werden kann, zeigt, dass Router sehr häufig verwendet werden. Für ein jeweiliges Framework gibt es außerdem in der Regel genau einen geläufigen Router, sodass sich hier keine besondere Bevorzugung stattgefunden hat. Stattdessen wurden alle drei Router gleichermaßen untersucht.

Als zweite Bibliothek wurde Redux untersucht. Wie bereits erläutert, verfügt React nicht über eine besonders empfohlene Methode zum zentralen Statemanagement. Diese Lücke kann jedoch von Redux gefüllt werden. Mithilfe von Redux kann ein zentraler sogenannter \glqq Store\grqq\ erzeugt werden. Dieser kann modifiziert werden, indem man an anderer Stelle eine sogenannte \glqq Action\grqq\ erzeugt, die an den Store weitergeleitet wird. Daraufhin werden sogenannte \glqq Reducer\grqq\ aufgerufen, die den aktuellen Wert des Stores und die aktuelle Action entgegennehmen und einen neuen, entsprechend der Action und ggf. zusätzlich überreichten Nutzdaten aktualisierten Store zurückgeben.

Diese Reducer sind stets pure Funktionen\footnote{D.h. sie sind seiteneffektfrei und ergeben bei gleicher Eingabe immer die gleiche Ausgabe.} und sind daher (da sie keinen Initialisierungsprozess voraussetzen und nichts anderes beeinflussen) sehr leicht testbar. Außerdem ermöglicht Redux in Kombination mit einer Browsererweiterung mehrere interessante Features, darunter ein Feature namens \glqq Zeitreise\grqq\, mit dem man den Store zu einem beliebigen vorherigen Stand zurücksetzen kann.

Redux lässt sich als eine Implementierung des Kommandopatterns betrachten. Hierbei stellen die Actions die Kommandos dar und der Store ist der Ausführer, der auch die Kommandohistorie verwaltet. Entsprechend stellt Redux auch automatisch eine Aufwandslose Undo-Redo-Funktionalität zur Verfügung.

Da Redux die meistverwendete Bibliothek für Statemanagement ist \cite{stateofjs}, wird ihre Installation stellvertretend für Alternativen wie MobX betrachtet. Ausnahme hiervon bildet jedoch Vuex, da es eine sehr hohe Ähnlichkeit zu Redux aufweist, sich mit besonders wenig Aufwand in einem Vue-Projekt installieren lässt und es für Vue-Projekte anstelle von Redux empfohlen wird \cite{vuejs_docs:redux_vs_vuex}.

Aufgrund ihrer großen Frameworkbindung wurden außerdem Komponentenbibliotheken untersucht. Gerade für kleine Projekte, in denen keine eigenen Designer angestellt sind, kann es sich sehr lohnen, eine Kombonentenbibliothek einzubinden. Da diese jeweils für ein Framework Komponenten bereitstellen muss, gibt es in der Regel für verschiedene Design Systeme jeweils eine Bibliothek pro Framework.

Stellvertretend für andere Komponentenbibliotheken wurden drei Material-Design-Bibliotheken untersucht: Material UI für React, Angular Material für Angular und Vuetify für Vue.

Um abschließend noch eine Bibliothek zu betrachten, die an sich keinerlei Bindung an Frameworks hat aber trotzdem in die Applikation eingebunden werden muss, wurde willkürlich als Beispiel paper.js ausgewählt. Diese Bibliothek erleichtert den Umgang mit dem HTML Canvas. Für sie muss zwar eine Komponente erzeugt werden, die ins \gls{DOM} eingebunden wird, aber darüber hinaus muss sie im Gegensatz zu den anderen Bibliotheken nicht in andere Teile der Applikation eingebunden werden.

\subsection{Vergleich der Installationsprozesse}
Beim manuellen Installieren der verschiedenen Werkzeugen und Bibliotheken sind einige Gemeinsamkeiten und vor allem in den Details viele Unterschiede aufgefallen. Auf einer allgemeineren, konzeptuellen Ebene lässt sich aber vor allem (wie bereits geschehen) zwischen Werkzeugen und Bibliotheken unterscheiden.

Allgemeinhin müssen für beides zunächst \gls{npm}-Pakete installiert werden. Daraufhin benötigen aber Werkzeuge meist die Änderung von Konfigurationsdateien, während zur Einbindung von Bibliotheken eher der produktive Code modifiziert werden muss.

\subsubsection{Installationen von Werkzeugen}
Zur Installation von Prettier ist beispielsweise lediglich noch die Erstellung einer Konfigurationsdatei für Prettier notwendig. Theoretisch kann auch auf diese Verzichtet werden, aber da ein Ziel des Projektes ist, dass Nutzende alles Wichtige für die meiste Arbeit eingerichtet bekommen, ist es sinnvoll, die Datei bereits zu erstellen und mit sinnvollen Standardwerten zu füllen. Darüber hinaus ist es ratsam, zur leichteren Ausführung von Prettier (wie bei den meisten anderen Werkzeugen auch) ein \gls{npm}-Script zu erzeugen. Hierfür muss die package.json-Datei modifiziert werden können.

Ähnlich ist bei der Installation von ESLint vorzugehen. In der Regel bedarf es lediglich der Installation des Paketes, der Einrichtung eines entsprechenden Scripts und der Erzeugung der Konfigurationsdatei. Leider wird der Installationsprozess bei der Benutzung von Angular dadurch verkompliziert, dass hier standardmäíg zunächst das veraltete TSLint eingebunden ist. Allerdings gibt es bereits ein \gls{npm}-Paket\footnote{\url{https://github.com/angular-eslint/angular-eslint}}, was den Wechsel auf ESLint automatisch durchführen kann.

Mit überdurchschnittlich wenig Aufwand lässt sich Sass / SCSS installieren. Sowohl Angular als auch Vue verfügen hierzu über einen Parameter bei der initialen Installation. Bei React muss man zwar das node-sass Paket installieren, aber weitere Einrichtung muss nicht vorgenommen werden.

Überdurchschnittlich viel Aufwand verursachten dahingegen Jest und Cypress. In Kombination mit React wird Jest zwar automatisch installiert und im Vue-\gls{CLI} gibt es hierfür eine entsprechende Option. Allerdings setzt Angular bisher auf Karma als Testausführer und Mocha als Assertion Library, weshalb hier nicht nur eine Installation von Jest sondern auch eine Anpassung bestehender Scripte und alter Tests notwendig ist. Wie auch schon bei ESLint gibt es ein Paket, was den Umstieg bis auf die Aktualisierung der Tests selber automatisch durchführen kann. Da im Kontext dieses Projekts bei der Ausführung noch keine speziellen Tests entstanden sein können, kann diese Aufgabe hier durch ein schlichtes Austauschen von festgelegten, vorgefertigten Dateien erledigt werden.

Die Installation von Cypress ist vergleichsweise zwar simpel und benötigt lediglich das Installieren neuer \gls{npm}-Pakete, das erstellen eines Scripts in der package.json-Datei und das Erzeugen neuer Dateien. Dieser Prozess kann im Kontext von Vue sogar von der initialen Projekterstellung abgenommen werden und auch in Angular-Applikationen kann er mithilfe eines \gls{npm}-Pakets automatisiert werden. Allerdings ergibt sich in genau der Kombination (d.h. in Angular-Projekten) eine Komplikation, wenn auch Jest installiert wurde. Dieses Problem lässt sich durch Modifikation der jest.config.js-Datei beheben \cite{angular_jest_cypress_issue}.

Da das Schreiben von Test sowohl für Jest als auch für Cypress sowohl in JavaScript als auch in TypeScript erfolgen kann, sollten die automatisch eingerichteten Tests in derjenigen der beiden Sprachen sein, die auch für den Produktivcode verwendet wird. Es ist also bei der Installation notwendig zu wissen, ob TypeScript verwendet wird oder nicht.

Eine letzte Besonderheit ergibt sich bei der Installation von Husky und lint-staged. Hier sind zwar ähnliche Schritte wie bei anderen Werkzeugen notwendig, aber zusätzlich wird hier eine Liste von Befehlen bzw. Skripten benötigt, die vor bestimmten Git-Prozessen ausgeführt werden sollen.

Zusammenfassend ist für die Installation von Werkzeugen also eine Kenntnis über die Verwendung von TypeScript nötig. Es muss auch bekannt sein, ob unter den anderen ausgewählten Werkzeugen solche dabei sind, die vor Git-Prozessen ausgeführt werden sollen. Darüber hinaus ist die Installation von \gls{npm}-Paketen sowie die Modifikation einiger Dateien notwendig. Diese Dateien sind entweder im \gls{JSON}-Format oder sind JavaScript- / TypeScript-Dateien. Außerdem muss es möglich sein, neue Dateien mit vorbestimmtem Inhalt zu erzeugen, der sich an den JavaScript-Dialekt anpassen können muss.

\subsubsection{Installationen von Bibliotheken}
Auch bei der Installation von Bibliotheken gibt es viele Gemeinsamkeiten, aber hier sind deutlich größere Unterschiede zwischen den Frameworks zu vermerken. Dies ist vorallem dadurch zu begründen, dass die Benutzung der Bibliotheken innerhalb bestimmter Komponenten geschieht und daher entweder bestehende Komponenten modifiziert oder neu erstellte Komponenten eingebunden werden müssen. Aufgrund dieser Bindung an Komponenten muss das entsprechende Vorgehen an jedes Framework einzeln angepasst werden.

Ein gutes Beispiel hierfür ist die Installation von paper.js. Da es sich hier nur um eine spezielle Bibliothek handelt, ist sie die einzige, die in keinem Framework vorinstallierbar ist, und eignet sich daher besonders gut für diesen Vergleich. Zur sinnvollen Benutzung von paper.js ist es notwendig, einen Canvas auf der Webseite anzuzeigen. Sobald dieser Canvas existiert, kann paper.js initialisiert werden und etwas auf dem Canvas zeichnen (zu Demonstrationszwecken genügt ein einfaches Rechteck).

Hierfür lässt sich in allen drei Frameworks eine Komponente schreiben, die dann in die Hauptkomponente eingebettet werden muss. Die dafür erforderlichen Dateiveränderungen sind jedoch sehr verschieden.

In Vue muss beispielsweise die zu verwendende Komponente einerseits dort eingefügt werden, wo sie anschließend im \gls{DOM} erscheinen soll. Andererseits muss sie im Script-Block importiert werden. Danach folgt eine Besonderheit von Vue, die in React und Angular nicht notwendig ist: es muss deklariert werden, dass die Komponente verwendet werden wird. Dieses Attribut des Konfigurationsobjektes muss bei der ersten Komponente, die eingefügt werden soll, neu erzeugt werden, während es bei allen weiteren neuen Komponenten nur ergänzt werden muss.

Dieses eine Codebeispiel zeigt bereits, dass es schon für simple Installationen von Bibliotheken notwendig ist, framework-spezifischen Code modifizieren zu können. Hierfür wäre es hilfreich, ein tiefes Verständnis des zu modifizierenden Codes zu haben. Da aber die Struktur des vorher existierenden Codes bekannt ist (unter der Annahme, dass sich die initialen Setups nicht auf relevante Art und Weise verändern werden) und da die vorzunehmenden Änderungen sich innerhalb eines Frameworks immer ähneln, kann diese geringe Menge von Änderungen bzw. Änderungsarten auch ohne ein solches tiefes Verständnis umgesetzt werden. Genauer wird hierauf in Kapitel \ref{implementierung} eingegangen.

Die Komponentenbibliotheken lassen sich mehrheitlich ohne bereits bekannte Probleme einbinden; häufig sogar automatisch bei der initialen Projekterzeugung mittels des Framework-spezifischen \gls{CLI}'s.

Neue Probleme weisen jedoch die Einbindung von Redux und Routern auf. Diese Bibliotheken bauen beide darauf auf, dass gewisse Informationen global verfügbar sind (in Redux der Store und in Routern die aktuelle Route).

In React ist das umsetzbar, indem die oberste Komponente von sogenannten \glqq Providern\grqq\ umgeben wird, die einen Wert und einen zugehörigen Schlüssel entgegennehmen und dann jeder ihnen unterliegenden Komponente den Wert unter dem jeweiligen Schlüssel zur Verfügung stellen. Das Umgeben der obersten Komponente ist also notwendig, damit alle Komponenten der gesamten Applikation Zugriff auf diese Werte haben. Falls dies nicht gewünscht ist, kann der zugehörige Provider verschoben werden.

In Angular ist es für eine möglichst simple Verwendung von Redux sinnvoll, einen Angular-Service einzurichten. Dies ermöglicht die einfache Erstellung eines Singleton Store-Objektes und erlaubt es gleichzeitig, mit Angular-typischen Mitteln wie RxJS\footnote{\url{https://rxjs.dev/}}-Methoden auf den Store zuzugreifen. Im Grunde genommen handelt es sich hierbei aber erneut nur um das erstellen einer Datei mit vorbestimmtem Inhalt.

Im Zusammenhang mit Vue fallen keine weiteren Probleme auf, da hier für Redux Vuex substituiert wird und sowohl Vuex als auch der Vue Router bereits automatisch installierbar sind.

\subsubsection{Zusammenfassung der notwendigen Installationsschritte}
Über die Werkzeuge und Bibliotheken hinweg zeigt sich, dass sich vieles über einfache Befehle installieren lässt, ohne, dass ein weiterer Aufwand betrieben werden muss. Für andere Installationen ist es ausnahmslos notwendig, gegebene Pakete von \gls{npm} installieren zu können. Wünschenswert wäre es auch, hierfür einen anderen Installer wie Yarn\footnote{\url{https://yarnpkg.com/}} verwenden zu können, der aber dieselben Pakete installiert. Es muss außerdem möglich sein, neue Dateien an bestimmten Orten zu erzeugen und diese mit Inhalten zu füllen, die sich nach der getroffenen Auswahl von Werkzeugen und Bibliotheken richten können.

Außerdem muss die Modifikation bestimmter Dateien ermöglicht werden. Zum einen muss es möglich sein, verschiedene \gls{JSON}-Dateien zu verändern. Zum anderen muss frameworkspezifischer Code ergänzt und modifiziert werden können. Außerdem muss die Reihenfolge der Installation der Werkzeuge bzw. Bibliotheken festlegbar sein, da beispielsweise Husky und lint-staged als letzte Werkzeuge installiert werden sollten.

\subsection{Bestimmung der erwünschten Features}
\label{konz:all_features}
Grundsätzlich soll \gls{GWA} drei Aufgaben übernehmen: Nutzende sollen nach ihren Präferenzen gefragt werden und sie sollen die Möglichkeit bekommen, interaktiv mit vielen hilfreichen Informationen eine Konstellation von Werkzeugen und Bibliotheken zusammenzustellen, die sie in ihrem Projekt haben wollen.

Da aber nicht jede solche Kombination möglich oder sinnvoll ist (beispielsweise kann bis auf in Spezialfällen nur maximal ein Framework gleichzeitig benutzt werden) bzw. bestimmte Bibliotheken von anderen abhängen (Angular ist beispielsweise nicht ohne TypeScript nutzbar), ist es danach notwendig, dass die Angaben der Nutzenden validiert werden. Sind alle Wünsche umsetzbar, so ist als dritte und letzte Aufgabe die erwünschte Installation vorzunehmen.

In der Praxis soll die Abarbeitung der Aufgaben etwas mehr ineinander übergehen. Beispielsweise ist es wünschenswert, dass nach jedem Zwischenschritt bereits so viel Validierung vorgenommen wird, wie möglich, damit nicht erst nach einer langen Konfiguration festgestellt wird, dass die Auswahl gar nicht umsetzbar ist. Nach Möglichkeit sollte nach jeder unzulässigen Antwort dieselbe Frage erneut gestellt werden oder weiterhin beantwortbar bleiben, bis eine zulässige Antwort gegeben worden ist. Nur, wo das nicht möglich oder nicht praktikabel ist, soll \gls{GWA} mit einem Fehlercode abgebrochen werden.

Erstmal ist es nicht notwendig, Projekte ohne ein Framework zu unterstützen. Diese Entscheidung rührt daher, dass bei frameworkunabhängigen Projekten von Anfang an viel mehr entschieden und einrichtet werden muss. Beispielsweise muss der Compilierprozess manuell eingerichtet werden und es muss ein lokaler Entwicklungsserver aufgesetzt werden. Zudem liegen die Gründe dafür, kein Framework zu benutzen, häufig darin, dass ein sehr spezielles Projekt geplant wird, das den Rahmen von \gls{GWA} ohnehin überschreiten würde (z.B. Entwicklung von Teilen der Applikation in WebAssembly). In diesen Fällen wäre die Unterstützung eines Projektes ohne Framework also auch nicht hilfreich. Da die Komplexität  dieses Features aber erheblich größer wäre als bei den drei bereits diskutierten Frameworks, wir vorerst darauf verzichtet.

Wie bereits erwähnt, soll es möglich sein, den Paketmanager auszutauschen (also z.B. statt \gls{npm} Yarn zu verwenden). Diese Austauschbarkeit lässt sich leicht mit dem Strategiemuster umsetzen, da die im Rahmen von \gls{GWA} genutzten Features von allen diesen Managern gleichermaßen unterstützt werden und ähnliche Schnittstellen anbieten. Nutzenden soll also zu Beginn die Wahl eines Paketmanagers gegeben werden, der dann auch genutzt werden soll.

Bei der Planung und Entwicklung von \gls{GWA} muss auch bedacht werden, dass \gls{GWA} nach seiner Ausführung das Projekt nicht mehr begleiten wird und es daher auch ohne \gls{GWA} betrieben und gewartet werden können muss. Da zumindest im Fall von Angular und Vue die zugehörigen \gls{CLI}s auch für die Pflege genutzt werden können, ist es sehr empfehlenswert, dafür zu sorgen, dass die Projekte nach der Installation über \gls{GWA} damit kompatibel sind.

\label{decision_use_clis}
Daher kann es sinnvoll sein, bei der Installation so viele Schritte wie möglich über die zugehörigen \gls{CLI}s zu machen. So gäbe es möglichst wenige Aktionen, die von \gls{GWA} vorgenommen werden, die die Kompatibilität zu den \gls{CLI}s gefärden könnten. Natürlich ist auch zu beachten, dass auf diese Weise viel Aufwand gespart werden kann, weil dann viele Aufgaben nicht manuell implementiert werden müssten, sondern auf bereits existierende und bewährte Lösungen gesetzt werden könnte.

Ein Nachteil dieses Ansatzes ist, dass er die verwendbaren Paketmanager erheblich einschränken würde. Das React-\gls{CLI} unterstützt bereits nur \gls{npm} und Yarn \cite{cra_package_managers} und somit könnten andere Paketmanager nicht von \gls{GWA} angeboten werden.

Der alternative Ansatz wäre, für alle Frameworks die komplette Erzeugung des Frameworks zu übernehmen. Das hätte zwar den Vorteil, dass man klar regeln könnte, wann welches Werkzeug / welche Bibliothek installiert wird (sonst könnte z.B. die Komponentenbibliothek mal in der Initialeinrichtung beinhaltet sein und mal erst anschließend ergänzt werden). Außerdem hätte \gls{GWA} so mehr Kontrolle über die Einheitlichkeit der erzeugten Projekte.

Nach diesen Überlegungen überwiegen die Vorteile des Ansatzes, möglichst viele der \gls{CLI}s und sonstigen Werkzeuge zu verwenden. Diese Entscheidung kann natürlich für jedes einzelne Werkzeug / jede einzelne Bibliothek erneut abgewogen werden, aber im Allgemeinen wird dieser Ansatz verfolgt werden.

Ein weiterer Fokus der Entwicklung liegt auf Erweiterbarkeit. Da es in der Zukunft neue Werkzeuge und Bibliotheken geben wird, die auch über \gls{GWA} installierbar sein sollen, muss es leicht möglich sein, \gls{GWA} um ein Werkzeug oder eine Bibliothek zu erweitern. Dies soll über ein Erweiterungssystem erreicht werden, auf das im Folgenden noch genauer eingegangen werden wird. Erweiterungen sollen zum einen Metadaten über das entsprechende Werkzeug / die Bibliothek zur Verfügung stellen; zum anderen sollen sie aber auch über die Möglichkeit verfügen, Nutzenden Fragen zu stellen und anschließend entsprechend dieser Fragen und mit Kenntnis der anderen ausgewählten Erweiterungen eine entsprechende Teilinstallation durchzuführen.

Um die Erweiterbarkeit von \gls{GWA} zu demonstrieren, sind exemplarisch einige Erweiterungen zu entwickeln. Hierbei besteht kein Anspruch auf Vollständigkeit, sondern vielmehr geht es darum, zu demonstrieren, dass das Schreiben von Erweiterungen verschiedener Arten möglich ist und wo möglich vom Grundgerüst unterstützt wird. Der Fokus bei der Entwicklung von Erweiterungen liegt daher nicht auf Quantität, sondern auf Vielseitigkeit.

\subsection{Abwägung über Sonderstellungen für TypeScript und Frameworks}
Aus den letzten Unterkapiteln geht hervor, dass sowohl TypeScript als auch das jeweils verwendete Framework eine wichtigere Funktion als sonstige Bibliotheken oder Werkzeuge haben. Bei TypeScript liegt das daran, dass für viele Bibliotheken je ein weiteres \gls{npm}-Paket für die Typdefinitionen installiert werden muss und neu erzeugte Dateien sowohl eine andere Endung haben müssen als auch mit anderem Inhalt gefüllt werden müssen.

Daher wäre eine Möglichkeit, TypeScript nicht in Form einer herkömmlichen Erweiterung einzubauen, sondern fester in den Code zu integrieren. Der Code könnte dadurch leserlicher werden, da an mehr Stellen explizit klar würde, dass und warum Sonderfälle existieren. Dieses Vorgehen hätte jedoch den erheblichen Nachteil, dass in der Zukunft keine JavaScript-Dialekte mehr (ohne erheblichen Aufwand) unterstützt werden könnten, falls neue entwickelt und populär werden sollten.

Wenn also genügend Fokus auf die verständliche Entwicklung entsprechender Sonderfälle gelegt wird, ist die TypeScript-Unterstützung in Form einer normalen Erweiterung zu implementieren.

Im Fall der Frameworks ist eine ähnliche Überlegung aus anderen Gründen sinnvoll. Wie bereits erläutert worden ist, können manche Werkzeuge / Bibliotheken von bestimmten Frameworks initial mitinstalliert werden, aber von anderen nicht. Da diese Möglichkeit auch genutzt werden soll (siehe Kapitel \ref{decision_use_clis}), müssten also entweder solche Erweiterungen in den Ablauf der Installation eines Frameworks eingreifen und diesen manipulieren können, oder solche Erweiterungen müssten im Rahmen einer solchen Installation deaktiviert werden können, damit das Framework die Installation übernehmen kann und keine Konflikte entstehen.

Der Eingriff in die Installation der Frameworks wäre sehr komplex umzusetzen. Da Werkzeuge / Bibliotheken immer nach dem Framework installiert werden müssen (sofern sie eben installiert werden müssen), wäre also die Installation des Frameworks eigentlich schon dabei, bevor eine Erweiterung überhaupt dazu kommen könnte, sie zu manipulieren. Außerdem wäre eine solche Manipulation per Definition ein Seiteneffekt und würde damit, wie bereits erläutert, die Testbarkeit der Erweiterung und der Installation erschweren. Daher scheidet dieses Vorgehen aus.

Die Deaktivierung einer Erweiterung wäre zwar erstmal auch als Seiteneffekt zu betrachten. Allerdings müssen Erweiterungen bei der Installation sowieso eine Liste der anderen ausgewählten Erweiterungen erhalten. Eine Erweiterung könnte sich also aufgrund dieser Liste selber deaktivieren anstatt von außen deaktiviert zu werden. So wäre das Verhalten wieder leicht testbar.

Infolge dieser Überlegungen sind also sowohl TypeScript als auch andere Frameworks als normale Erweiterungen zu implementieren.

\subsection{Planung der Erweiterungen}
Um einheitlich mit allen Erweiterungen umgehen zu können, sollten diese ein gewisses Interface implementieren\footnote{In der tatsächlichen Implementierung wird aufgrund des Vorgehens nach funktionaler Programmierung ein TypeScript Type anstelle eines Interfaces verwendet. Dieser Unterschied spielt an dieser Stelle jedoch keine Rolle.}. Neben einigen Metadaten (wie Name, Beschreibung oder Kategorie), die vor allem zu Anzeige- und Informationszwecken genutzt werden, müssen einige inhaltliche Eigenschaften deklarierbar sein.

Als erstes ist die Durchführung des Dialogs zu betrachten. Die initiale Auswahl der Erweiterungen kann von Außerhalb der einzelnen Erweiterungen erledigt werden. Dafür ist es neben den Metadaten notwendig, dass Erweiterungen ihre Abhängigkeiten und Exklusivitäten deklarieren können, damit die getätigte Auswahl überprüft werden kann.

Nach der initialen Auswahl der Erweiterungen muss jede der ausgewählten Erweiterungen die Möglichkeit bekommen, weitere Nachfragen zu stellen. Hierfür kann eine Erweiterung eine Methode definieren, die als Eingabeparameter alle notwendigen Objekte zum Stellen von Fragen und Analysieren der Antworten erhält und ein Objekt mit den bereits verarbeiteten Antworten des Users (also den gewünschten Einstellungen) zurück gibt. Dieser Funktion könnte auch als weiterer Eingabeparameter eine Liste aller \gls{CLI}-Optionen gegeben werden, sodass zum einen bereits darüber beantwortete Fragen nicht erneut gestellt werden müssen und zum anderen diese Optionen in die Erzeugung des Einstellungsobjekts mit einfließen können.

Um die eigentliche Installation zu ermöglichen, muss es eine Methode geben, die genau diesen Schritt ausführt. Als Eingabe benötigt sie eine Liste aller ausgewählten Erweiterungen sowie deren Einstellungen (damit vor allem Frameworks die Mitinstallation anderer Bibliotheken oder Werkzeuge gemäß den angegebenen Präferenzen vornehmen können). Außerdem müssen auch sonstige über das Projekt bekannte Daten (z.B. der gewünschte Name des Projektes) übergeben werden (diese sind z.B. auch für die initiale Einrichtung des Frameworks erforderlich).

Anschließend kann es hilfreich sein, wenn abschließende Hilfsinformationen für Nutzende ausgegeben werden können, damit die nächsten Schritte mit einer Bibliothek oder einem Werkzeug erläutert werden können. Hierfür kann deshalb eine zusätzliche Methode angegeben werden, die als Parameter dieselben Daten wie die Installationsfunktion übergeben bekommt, um denselben Informationsstand zu haben und Aussagen über die durchgeführte Installation treffen zu können.

\subsection{Zu verwendende Technologien}
Aufgrund dessen, dass im Rahmen von \gls{GWA} JavaScript-Projekte eingerichtet werden sollen, die auf \gls{npm}-Projekten aufbauen sollen, ist es sinnvoll, auch dieses Projekt innerhalb des \gls{npm}-Ökosystems aufzubauen. Somit können Entwickelnde, die eine Bibliothek oder ein Werkzeug erstellt haben, in derselben Programmiersprache auch an \gls{GWA} mitarbeiten, wodurch die Pflege des \gls{CLI}s erleichtert werden könnte.

Als primäre Programmiersprache wird anstelle reinen JavaScripts TypeScript zum Einsatz kommen. Die dadurch gewonnene Typsicherheit ist insbesondere aufgrund dessen nützlich, dass neue Entwickelnde beim Einstieg in das Projekt leichter verstehen können, an welcher Stelle welche Daten vorliegen.

Zur Durchführung des Dialogs (d.h. zum Stellen von Fragen und zur Darstellung von Informationen) werden inquirer\footnote{\url{https://www.npmjs.com/package/inquirer}} und chalk\footnote{\url{https://www.npmjs.com/package/chalk}} verwendet. Die Wahl auf beide Bibliotheken ist dadurch gefallen, dass sie von einigen der zuvor vorgestellten Generatoren verwendet werden. Die Fragen der Vue- und des Angular-\gls{CLI}s werden mithilfe von inquirer gestellt \cite{vue_cli_uses_inquirer} \cite{angular_cli_uses_inquirer} (wie bereits erwähnt, stellt \gls{CRA} gar keine Fragen) und inquirer selbst verwendet chalk zum farblichen Hervorheben von (Teilen von) Ausgaben \cite{inquirer_uses_chalk}.

Des weiteren werden einige Technologien verwendet, die keinen besonderen Einfluss auf das Programm selbst haben und die daher ohne besondere Recherche aufgrund von persönlicher Erfahrung und Präferenz ausgewählt werden. Diese Technologien umfassen insbesondere Jest, womit automatische Tests geschrieben und ausgeführt werden können, GitHub, worüber der Code des Projektes verwaltet wird, und Prettier.

Prettier wird aus zwei Gründen verwendet: einerseits lässt sich damit während der Entwicklung neu entstandener und modifizierter Code formatieren. Andererseits lässt sich Prettier auch programmatisch verwenden (es kann also direkt per JavaScript / TypeScript aufgerufen werden), weshalb Prettier ebenfalls zur Laufzeit verwendet werden kann, um erzeugte und modifizierte Dateien zu formatieren.
